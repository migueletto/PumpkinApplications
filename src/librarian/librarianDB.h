/***********************************************************************
 *
 * PROJECT:  Librarian
 * FILE:     librarianDB.h
 * AUTHOR:   Lonnon R. Foster <author@palmosbible.com>
 *
 * DESCRIPTION:  Database header for Librarian.
 *
 * From Palm OS Programming Bible, Second Edition
 * Copyright ©2000, 2002 Lonnon R. Foster.  All rights reserved.
 * This code is not in the public domain, but you are hereby granted
 * permission to use it in any of your own projects, commercial or
 * otherwise.
 *
 * Portions Copyright ©2000 Palm, Inc. or its subsidiaries.
 * All rights reserved.
 *
 ***********************************************************************/

#define noRecord      0xffff
#define noFieldIndex  0xff

// Database versions.
#define libDatabaseVersion1_0_0   0  // Librarian version 1.0.0
#define libDatabaseVersion2_0_0   1  // Librarian version 2.0.0

// Sort orders; also control which fields are visible in the List view
#define libShowAuthorTitle     0
#define libShowTitleAuthor     1
#define libShowTitleOnly       2

// Maximum length of a label in the Edit view or a status string in the
// Record view
#define libLabelLength       16

// Number of field labels in the Edit view
#define libNumFieldLabels    8

// Number of status strings in the Record view
#define libNumBookStatusStrings    4
#define libNumPrintStatusStrings   3
#define libNumFormatStatusStrings  4
#define libNumReadStatusStrings    2

// Maximum length of a field in the Edit view.  This limit is imposed by
// the default length of a text table item, which can be hacked to hold
// more, but really isn't worth the bother; any data longer than 255
// characters really belongs in the record's note, not in any of its
// regular fields.
#define maxNameLength  255


// libLabel
// Each field label in the Edit view or status string in the Record view
// is stored in the application info block.
typedef char libLabel[libLabelLength];


// LibAppInfoType
// Application info block for Librarian.  Contains information about the
// application as a whole, such as category names and the current sort
// order for the database.

typedef struct {
    UInt16  renamedCategories; // bitfield of categories with a different name
    char    categoryLabels[dmRecNumCategories][dmCategoryLength];
    UInt8   categoryUniqIDs[dmRecNumCategories];
    UInt8   lastUniqID; // Unique IDs generated by the device are between
    // 0 - 127.  Those from the PC are 128 - 255.
    UInt8   reserved1; // from the compiler word aligning things
    UInt16  reserved2;
    UInt8  showInList; // Current sort order for database
    libLabel  fieldLabels[libNumFieldLabels];  // Labels in Edit view
    libLabel  bookStatusStrings[libNumBookStatusStrings];     // Record
    libLabel  printStatusStrings[libNumPrintStatusStrings];   // view
    libLabel  formatStatusStrings[libNumFormatStatusStrings]; // status
    libLabel  readStatusStrings[libNumReadStatusStrings];     // strings
} LibAppInfoType;


// LibDBRecordFlags
// Since the packed record format in LibPackedDBRecord does not store
// empty fields, Librarian uses LibDBRecordFlags to keep track of which
// fields contain data.  0 = empty field, 1 = a field containing text.

typedef union {
    struct {
        unsigned reserved   :7;  // Extra space for possible future fields
        unsigned note       :1;  // Set if record contains a note handle
        unsigned price      :1;  // Set if record contains a cover price
        unsigned isbn       :1;  // Set if record contains an ISBN
        unsigned printing   :1;  // Set if record contains a printing
        unsigned year       :1;  // Set if record contains a publishing date
        unsigned publisher  :1;  // Set if record contains a publisher
        unsigned firstName  :1;  // Set if record contains an author's first name
        unsigned lastName   :1;  // Set if record contains an author's last name
        unsigned title      :1;  // Set if record contains a book title
    } bits;
    UInt16 allBits;
} LibDBRecordFlags;


// LibFields
// Enum for identifying the text fields in a book record.

typedef enum {
    libFieldTitle = 0,
    libFieldLastName,
    libFieldFirstName,
    libFieldPublisher,
    libFieldYear,
    libFieldPrinting,
    libFieldIsbn,
    libFieldPrice,
    libFieldNote,
    libFieldsCount
} LibFields;


// LibStatusType
// Structure to keep track of the book status, print status, and read
// properties of a book record.  The bookStatus and printStatus fields
// use the BookStatusType and PrintStatusType enums; read is a simple
// boolean flag (0 = unread, 1 = read).

typedef struct {
    unsigned reserved     :1;
    unsigned bookStatus   :2;
    unsigned printStatus  :2;
    unsigned format       :2;
    unsigned read         :1;
} LibStatusType;


// BookStatusType
// Enum for the general status of a book.  Used with the bookStatus
// member of LibStatusType.

typedef enum {
    bookStatusHave = 0,
    bookStatusWant,
    bookStatusOnOrder,
    bookStatusLoaned,
    bookStatusCount
} BookStatusType;


// PrintStatusType
// Enum for the print status of a book record.  Note that the status
// field is actually four bits long, but Librarian only makes use of
// three of those bits.  Used with the printStatus member of LibStatusType.

typedef enum {
    printStatusInPrint = 0,
    printStatusOutOfPrint,
    printStatusNotPublished,
    printStatusCount
} PrintStatusType;


// FormatType
// Enum for the format of the book.  Used with the format member of
// LibStatusType.

typedef enum {
    formatHardcover = 0,
    formatPaperback,
    formatTradePaperback,
    formatOther,
    formatCount
} FormatType;

// LibDBRecordType
// This is the unpacked record form used by the application.  The fields
// array contains pointers to each of the text fields in the book record.
// Each pointer in the array is either NULL if the field is empty, or
// it points to the contents of the field.

typedef struct {
    LibStatusType  status;
    char           *fields[libFieldsCount];
} LibDBRecordType;


// LibPackedDBRecord
// This is the packed record form stored in the application's database.
// Each field is only stored if it contains any data.  The
// LibDBRecordFlags structure indicates which fields exist for the
// record.  The firstField member is actually the location of the first
// character of the first text field that contains data.  Each string
// representing a text field's contents is null-terminated.
//    The various offset variables are necessary to provide direct
// in-place access to key fields when sorting records.  The noteOffset
// value is no longer needed, because Librarian 2.0 uses a new method
// for finding the note field offset to edit it in-place.

typedef struct {
    LibStatusType     status;
    LibDBRecordFlags  flags;
    UInt16            lastNameOffset;
    UInt16            firstNameOffset;
    UInt16            yearOffset;
    char              firstField;
} LibPackedDBRecord;


// LibPackedDBRecordV0
// The unsigned char values used for the offsets in Librarian
// version 1.0.0 are not sufficient to hold offset values greater
// than 255, which can occur if there is a lot of text in the text
// fields preceding the field that a particular offset variable
// represents.  This subtle bug manifests both as incorrectly sorted
// records (in the case of the lastNameOffset, firstNameOffset, or
// yearOffset variables being off), or in missing or seemingly
// random text in the record's note (in the case of noteOffset being
// incorrect).
//    Fixing the error requires conversion of the database to a new
// format using UInt16 values instead of unsigned char.
typedef struct {
    LibStatusType     status;
    LibDBRecordFlags  flags;
    unsigned char     lastNameOffset;
    unsigned char     firstNameOffset;
    unsigned char     yearOffset;
    unsigned char     noteOffset;
    char              firstField;
} LibPackedDBRecordV0;

/***********************************************************************
 *
 *   Function Prototypes
 *
 ***********************************************************************/

       Err      LibAppInfoInit(DmOpenRef db);
       Err      LibChangeRecord(DmOpenRef db, UInt16 *index,
                         LibDBRecordType *record, 
                         LibDBRecordFlags changedFields);
       void     LibChangeSortOrder(DmOpenRef db, UInt8 showInList);
static Int16    LibComparePackedRecords(LibPackedDBRecord *r1,
                                        LibPackedDBRecord *r2,
                                        Int16 showInList,
                                        SortRecordInfoType *info1,
                                        SortRecordInfoType *info2,
                                        MemHandle appInfoH);
       Err      LibConvertDB (DmOpenRef db, UInt16 fromVersion,
                              UInt16 toVersion);
static void     LibFindKey(LibPackedDBRecord *record, char **key,
                           UInt16 *whichKey, Int16 showInList);
       UInt16   LibFindSortPosition(DmOpenRef db, LibPackedDBRecord *record);
       MemHandle LibGetAppInfo(DmOpenRef db);
static void     LibGetAppInfoStr(LibAppInfoType *appInfo, Int16 resourceID,
                                 Int16 stringCount, UInt32 arrayAddress);
       Err      LibGetDatabase(DmOpenRef *dbP, UInt16 mode);
static void     LibGetPrimaryField(LibPackedDBRecord *r, UInt8 showInList,
                                   char **primary);
       Err      LibGetRecord(DmOpenRef db, UInt16 index,
                             LibDBRecordType *record, MemHandle *recordH);
       UInt8    LibGetSortOrder(DmOpenRef db);
       Boolean  LibLookupChar(DmOpenRef db, char key, UInt16 category,
                       UInt8 showInList, UInt16 *foundRecord);
       Err      LibNewRecord(DmOpenRef db, LibDBRecordType *record,
                             UInt16 *index);
static UInt32   LibUnpackedSize(LibDBRecordType *record);
static void     PackRecord (LibDBRecordType *record, MemPtr recordDBEntry);
       Boolean  RecordContainsData (LibDBRecordType *record);
static void     UnpackRecord (LibPackedDBRecord *packed, 
                              LibDBRecordType *record);
